// Generated by debug/main.go. DO NOT EDIT.

package main

import (
	dst "github.com/dave/dst"
	"log"
)

func NodeToGraphNode(node dst.Node, level int, sequence int) *GraphNode {
	gNode := &GraphNode{Level: level, Sequence: sequence, Node: node, Edges: []*GraphEdge{}}
	var child *GraphNode
	nextLevel := level + 1
	nextSeq := 0
	switch n := node.(type) {
	case *dst.ArrayType:
		gNode.Type = "ArrayType"
		log.Println("ArrayType")
		if n.Len != nil {
			child = NodeToGraphNode(n.Len, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Len"})
			nextSeq++
		}
		if n.Elt != nil {
			child = NodeToGraphNode(n.Elt, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Elt"})
			nextSeq++
		}
	case *dst.SelectorExpr:
		gNode.Type = "SelectorExpr"
		log.Println("SelectorExpr")
		if n.X != nil {
			child = NodeToGraphNode(n.X, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "X"})
			nextSeq++
		}
		if n.Sel != nil {
			child = NodeToGraphNode(n.Sel, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Sel"})
			nextSeq++
		}
	case *dst.MapType:
		gNode.Type = "MapType"
		log.Println("MapType")
		if n.Key != nil {
			child = NodeToGraphNode(n.Key, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Key"})
			nextSeq++
		}
		if n.Value != nil {
			child = NodeToGraphNode(n.Value, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Value"})
			nextSeq++
		}
	case *dst.AssignStmt:
		gNode.Type = "AssignStmt"
		log.Println("AssignStmt")
		if n.Lhs != nil {
			for _, obj := range n.Lhs {
				child = NodeToGraphNode(obj, nextLevel, nextSeq)
				gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Lhs"})
				nextSeq++
			}
		}
		if n.Rhs != nil {
			for _, obj := range n.Rhs {
				child = NodeToGraphNode(obj, nextLevel, nextSeq)
				gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Rhs"})
				nextSeq++
			}
		}
	case *dst.ReturnStmt:
		gNode.Type = "ReturnStmt"
		log.Println("ReturnStmt")
		if n.Results != nil {
			for _, obj := range n.Results {
				child = NodeToGraphNode(obj, nextLevel, nextSeq)
				gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Results"})
				nextSeq++
			}
		}
	case *dst.BlockStmt:
		gNode.Type = "BlockStmt"
		log.Println("BlockStmt")
		if n.List != nil {
			for _, obj := range n.List {
				child = NodeToGraphNode(obj, nextLevel, nextSeq)
				gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "List"})
				nextSeq++
			}
		}
	case *dst.Field:
		gNode.Type = "Field"
		log.Println("Field")
		if n.Names != nil {
			for _, obj := range n.Names {
				child = NodeToGraphNode(obj, nextLevel, nextSeq)
				gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Names"})
				nextSeq++
			}
		}
		if n.Type != nil {
			child = NodeToGraphNode(n.Type, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Type"})
			nextSeq++
		}
		if n.Tag != nil {
			child = NodeToGraphNode(n.Tag, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Tag"})
			nextSeq++
		}
	case *dst.ExprStmt:
		gNode.Type = "ExprStmt"
		log.Println("ExprStmt")
		if n.X != nil {
			child = NodeToGraphNode(n.X, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "X"})
			nextSeq++
		}
	case *dst.UnaryExpr:
		gNode.Type = "UnaryExpr"
		log.Println("UnaryExpr")
		if n.X != nil {
			child = NodeToGraphNode(n.X, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "X"})
			nextSeq++
		}
	case *dst.FuncType:
		gNode.Type = "FuncType"
		log.Println("FuncType")
		if n.Params != nil {
			child = NodeToGraphNode(n.Params, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Params"})
			nextSeq++
		}
		if n.Results != nil {
			child = NodeToGraphNode(n.Results, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Results"})
			nextSeq++
		}
	case *dst.ChanType:
		gNode.Type = "ChanType"
		log.Println("ChanType")
		if n.Value != nil {
			child = NodeToGraphNode(n.Value, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Value"})
			nextSeq++
		}
		gNode.Value = "Dir"
	case *dst.DeferStmt:
		gNode.Type = "DeferStmt"
		log.Println("DeferStmt")
		if n.Call != nil {
			child = NodeToGraphNode(n.Call, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Call"})
			nextSeq++
		}
	case *dst.GenDecl:
		gNode.Type = "GenDecl"
		log.Println("GenDecl")
		if n.Specs != nil {
			for _, obj := range n.Specs {
				child = NodeToGraphNode(obj, nextLevel, nextSeq)
				gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Specs"})
				nextSeq++
			}
		}
	case *dst.StarExpr:
		gNode.Type = "StarExpr"
		log.Println("StarExpr")
		if n.X != nil {
			child = NodeToGraphNode(n.X, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "X"})
			nextSeq++
		}
	case *dst.LabeledStmt:
		gNode.Type = "LabeledStmt"
		log.Println("LabeledStmt")
		if n.Label != nil {
			child = NodeToGraphNode(n.Label, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Label"})
			nextSeq++
		}
		if n.Stmt != nil {
			child = NodeToGraphNode(n.Stmt, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Stmt"})
			nextSeq++
		}
	case *dst.ForStmt:
		gNode.Type = "ForStmt"
		log.Println("ForStmt")
		if n.Init != nil {
			child = NodeToGraphNode(n.Init, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Init"})
			nextSeq++
		}
		if n.Cond != nil {
			child = NodeToGraphNode(n.Cond, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Cond"})
			nextSeq++
		}
		if n.Post != nil {
			child = NodeToGraphNode(n.Post, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Post"})
			nextSeq++
		}
		if n.Body != nil {
			child = NodeToGraphNode(n.Body, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Body"})
			nextSeq++
		}
	case *dst.FuncDecl:
		gNode.Type = "FuncDecl"
		log.Println("FuncDecl")
		if n.Recv != nil {
			child = NodeToGraphNode(n.Recv, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Recv"})
			nextSeq++
		}
		if n.Name != nil {
			child = NodeToGraphNode(n.Name, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Name"})
			nextSeq++
		}
		if n.Type.Params != nil {
			child = NodeToGraphNode(n.Type.Params, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Params"})
			nextSeq++
		}
		if n.Type.Results != nil {
			child = NodeToGraphNode(n.Type.Results, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Results"})
			nextSeq++
		}
		if n.Body != nil {
			child = NodeToGraphNode(n.Body, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Body"})
			nextSeq++
		}
	case *dst.FieldList:
		gNode.Type = "FieldList"
		log.Println("FieldList")
		if n.List != nil {
			for _, obj := range n.List {
				child = NodeToGraphNode(obj, nextLevel, nextSeq)
				gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "List"})
				nextSeq++
			}
		}
	case *dst.IndexExpr:
		gNode.Type = "IndexExpr"
		log.Println("IndexExpr")
		if n.X != nil {
			child = NodeToGraphNode(n.X, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "X"})
			nextSeq++
		}
		if n.Index != nil {
			child = NodeToGraphNode(n.Index, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Index"})
			nextSeq++
		}
	case *dst.InterfaceType:
		gNode.Type = "InterfaceType"
		log.Println("InterfaceType")
		if n.Methods != nil {
			child = NodeToGraphNode(n.Methods, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Methods"})
			nextSeq++
		}
		gNode.Value = "Incomplete"
	case *dst.GoStmt:
		gNode.Type = "GoStmt"
		log.Println("GoStmt")
		if n.Call != nil {
			child = NodeToGraphNode(n.Call, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Call"})
			nextSeq++
		}
	case *dst.BadExpr:
		gNode.Type = "BadExpr"
		log.Println("BadExpr")
	case *dst.CallExpr:
		gNode.Type = "CallExpr"
		log.Println("CallExpr")
		if n.Fun != nil {
			child = NodeToGraphNode(n.Fun, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Fun"})
			nextSeq++
		}
		if n.Args != nil {
			for _, obj := range n.Args {
				child = NodeToGraphNode(obj, nextLevel, nextSeq)
				gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Args"})
				nextSeq++
			}
		}
	case *dst.EmptyStmt:
		gNode.Type = "EmptyStmt"
		log.Println("EmptyStmt")
		gNode.Value = "Implicit"
	case *dst.SendStmt:
		gNode.Type = "SendStmt"
		log.Println("SendStmt")
		if n.Chan != nil {
			child = NodeToGraphNode(n.Chan, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Chan"})
			nextSeq++
		}
		if n.Value != nil {
			child = NodeToGraphNode(n.Value, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Value"})
			nextSeq++
		}
	case *dst.BranchStmt:
		gNode.Type = "BranchStmt"
		log.Println("BranchStmt")
		if n.Label != nil {
			child = NodeToGraphNode(n.Label, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Label"})
			nextSeq++
		}
	case *dst.TypeSwitchStmt:
		gNode.Type = "TypeSwitchStmt"
		log.Println("TypeSwitchStmt")
		if n.Init != nil {
			child = NodeToGraphNode(n.Init, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Init"})
			nextSeq++
		}
		if n.Assign != nil {
			child = NodeToGraphNode(n.Assign, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Assign"})
			nextSeq++
		}
		if n.Body != nil {
			child = NodeToGraphNode(n.Body, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Body"})
			nextSeq++
		}
	case *dst.ImportSpec:
		gNode.Type = "ImportSpec"
		log.Println("ImportSpec")
		if n.Name != nil {
			child = NodeToGraphNode(n.Name, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Name"})
			nextSeq++
		}
		if n.Path != nil {
			child = NodeToGraphNode(n.Path, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Path"})
			nextSeq++
		}
	case *dst.BinaryExpr:
		gNode.Type = "BinaryExpr"
		log.Println("BinaryExpr")
		if n.X != nil {
			child = NodeToGraphNode(n.X, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "X"})
			nextSeq++
		}
		if n.Y != nil {
			child = NodeToGraphNode(n.Y, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Y"})
			nextSeq++
		}
	case *dst.BadStmt:
		gNode.Type = "BadStmt"
		log.Println("BadStmt")
	case *dst.CompositeLit:
		gNode.Type = "CompositeLit"
		log.Println("CompositeLit")
		if n.Type != nil {
			child = NodeToGraphNode(n.Type, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Type"})
			nextSeq++
		}
		if n.Elts != nil {
			for _, obj := range n.Elts {
				child = NodeToGraphNode(obj, nextLevel, nextSeq)
				gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Elts"})
				nextSeq++
			}
		}
		gNode.Value = "Incomplete"
	case *dst.TypeAssertExpr:
		gNode.Type = "TypeAssertExpr"
		log.Println("TypeAssertExpr")
		if n.X != nil {
			child = NodeToGraphNode(n.X, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "X"})
			nextSeq++
		}
		if n.Type != nil {
			child = NodeToGraphNode(n.Type, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Type"})
			nextSeq++
		}
	case *dst.DeclStmt:
		gNode.Type = "DeclStmt"
		log.Println("DeclStmt")
		if n.Decl != nil {
			child = NodeToGraphNode(n.Decl, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Decl"})
			nextSeq++
		}
	case *dst.CaseClause:
		gNode.Type = "CaseClause"
		log.Println("CaseClause")
		if n.List != nil {
			for _, obj := range n.List {
				child = NodeToGraphNode(obj, nextLevel, nextSeq)
				gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "List"})
				nextSeq++
			}
		}
		if n.Body != nil {
			for _, obj := range n.Body {
				child = NodeToGraphNode(obj, nextLevel, nextSeq)
				gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Body"})
				nextSeq++
			}
		}
	case *dst.SelectStmt:
		gNode.Type = "SelectStmt"
		log.Println("SelectStmt")
		if n.Body != nil {
			child = NodeToGraphNode(n.Body, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Body"})
			nextSeq++
		}
	case *dst.ValueSpec:
		gNode.Type = "ValueSpec"
		log.Println("ValueSpec")
		if n.Names != nil {
			for _, obj := range n.Names {
				child = NodeToGraphNode(obj, nextLevel, nextSeq)
				gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Names"})
				nextSeq++
			}
		}
		if n.Type != nil {
			child = NodeToGraphNode(n.Type, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Type"})
			nextSeq++
		}
		if n.Values != nil {
			for _, obj := range n.Values {
				child = NodeToGraphNode(obj, nextLevel, nextSeq)
				gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Values"})
				nextSeq++
			}
		}
	case *dst.IncDecStmt:
		gNode.Type = "IncDecStmt"
		log.Println("IncDecStmt")
		if n.X != nil {
			child = NodeToGraphNode(n.X, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "X"})
			nextSeq++
		}
	case *dst.Ellipsis:
		gNode.Type = "Ellipsis"
		log.Println("Ellipsis")
		if n.Elt != nil {
			child = NodeToGraphNode(n.Elt, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Elt"})
			nextSeq++
		}
	case *dst.IfStmt:
		gNode.Type = "IfStmt"
		log.Println("IfStmt")
		if n.Init != nil {
			child = NodeToGraphNode(n.Init, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Init"})
			nextSeq++
		}
		if n.Cond != nil {
			child = NodeToGraphNode(n.Cond, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Cond"})
			nextSeq++
		}
		if n.Body != nil {
			child = NodeToGraphNode(n.Body, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Body"})
			nextSeq++
		}
		if n.Else != nil {
			child = NodeToGraphNode(n.Else, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Else"})
			nextSeq++
		}
	case *dst.SwitchStmt:
		gNode.Type = "SwitchStmt"
		log.Println("SwitchStmt")
		if n.Init != nil {
			child = NodeToGraphNode(n.Init, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Init"})
			nextSeq++
		}
		if n.Tag != nil {
			child = NodeToGraphNode(n.Tag, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Tag"})
			nextSeq++
		}
		if n.Body != nil {
			child = NodeToGraphNode(n.Body, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Body"})
			nextSeq++
		}
	case *dst.BasicLit:
		gNode.Type = "BasicLit"
		log.Println("BasicLit")
		gNode.Value = "Value"
		gNode.Value = "Kind"
	case *dst.CommClause:
		gNode.Type = "CommClause"
		log.Println("CommClause")
		if n.Comm != nil {
			child = NodeToGraphNode(n.Comm, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Comm"})
			nextSeq++
		}
		if n.Body != nil {
			for _, obj := range n.Body {
				child = NodeToGraphNode(obj, nextLevel, nextSeq)
				gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Body"})
				nextSeq++
			}
		}
	case *dst.File:
		gNode.Type = "File"
		log.Println("File")
		if n.Name != nil {
			child = NodeToGraphNode(n.Name, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Name"})
			nextSeq++
		}
		if n.Decls != nil {
			for _, obj := range n.Decls {
				child = NodeToGraphNode(obj, nextLevel, nextSeq)
				gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Decls"})
				nextSeq++
			}
		}
		if n.Imports != nil {
			for _, obj := range n.Imports {
				child = NodeToGraphNode(obj, nextLevel, nextSeq)
				gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Imports"})
				nextSeq++
			}
		}
	case *dst.Package:
		gNode.Type = "Package"
		log.Println("Package")
		gNode.Value = "Name"
	case *dst.StructType:
		gNode.Type = "StructType"
		log.Println("StructType")
		if n.Fields != nil {
			child = NodeToGraphNode(n.Fields, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Fields"})
			nextSeq++
		}
		gNode.Value = "Incomplete"
	case *dst.KeyValueExpr:
		gNode.Type = "KeyValueExpr"
		log.Println("KeyValueExpr")
		if n.Key != nil {
			child = NodeToGraphNode(n.Key, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Key"})
			nextSeq++
		}
		if n.Value != nil {
			child = NodeToGraphNode(n.Value, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Value"})
			nextSeq++
		}
	case *dst.RangeStmt:
		gNode.Type = "RangeStmt"
		log.Println("RangeStmt")
		if n.Key != nil {
			child = NodeToGraphNode(n.Key, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Key"})
			nextSeq++
		}
		if n.Value != nil {
			child = NodeToGraphNode(n.Value, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Value"})
			nextSeq++
		}
		if n.X != nil {
			child = NodeToGraphNode(n.X, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "X"})
			nextSeq++
		}
		if n.Body != nil {
			child = NodeToGraphNode(n.Body, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Body"})
			nextSeq++
		}
	case *dst.TypeSpec:
		gNode.Type = "TypeSpec"
		log.Println("TypeSpec")
		if n.Name != nil {
			child = NodeToGraphNode(n.Name, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Name"})
			nextSeq++
		}
		if n.Type != nil {
			child = NodeToGraphNode(n.Type, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Type"})
			nextSeq++
		}
	case *dst.ParenExpr:
		gNode.Type = "ParenExpr"
		log.Println("ParenExpr")
		if n.X != nil {
			child = NodeToGraphNode(n.X, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "X"})
			nextSeq++
		}
	case *dst.FuncLit:
		gNode.Type = "FuncLit"
		log.Println("FuncLit")
		if n.Type != nil {
			child = NodeToGraphNode(n.Type, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Type"})
			nextSeq++
		}
		if n.Body != nil {
			child = NodeToGraphNode(n.Body, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Body"})
			nextSeq++
		}
	case *dst.SliceExpr:
		gNode.Type = "SliceExpr"
		log.Println("SliceExpr")
		if n.X != nil {
			child = NodeToGraphNode(n.X, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "X"})
			nextSeq++
		}
		if n.Low != nil {
			child = NodeToGraphNode(n.Low, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Low"})
			nextSeq++
		}
		if n.High != nil {
			child = NodeToGraphNode(n.High, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "High"})
			nextSeq++
		}
		if n.Max != nil {
			child = NodeToGraphNode(n.Max, nextLevel, nextSeq)
			gNode.Edges = append(gNode.Edges, &GraphEdge{Dest: child, Relationship: "Max"})
			nextSeq++
		}
		gNode.Value = "Slice3"
	case *dst.Ident:
		gNode.Type = "Ident"
		log.Println("Ident")
		gNode.Value = "Name"
	case *dst.BadDecl:
		gNode.Type = "BadDecl"
		log.Println("BadDecl")
	}
	return gNode
}
